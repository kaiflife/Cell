<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="" />
		<title>Constructor</title>
		<style>
			body {
				margin: 0;
				padding: 0;
			}

			.menuModal {
				display: none;
				position: fixed;
				flex-direction: column;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;

				&.show {
					display: flex;
				}

				.header {
					display: flex;
					width: 100vw;
					height: 32px;
					overflow-x: auto;

					div {
						color: red;

						&::before {
							content: "/";
						}
					}
				}

				.main {
					display: flex;
					flex-direction: column;
					height: calc(100vh - 32px);
					overflow-y: auto;
				}
			}

			header {
				height: 32px;
			}

			main {
				height: calc(100vh - 32px);
				width: 100vw;
				position: relative;
			}

			.editMode {
				.cell {
					border: 1px solid black;

					&.selected {
						border-color: red;
					}
				}
			}

			.level {
				width: 32px;
			}
		</style>
	</head>

	<body>
		<div id="menuModal" class="menuModal">
			<div class="header" id="menuModalHeader"></div>
			<div class="main" id="menuModalMain"></div>
		</div>
		<main id="main"></main>
		<footer>
			<button onclick="toggleMenuModal()">Menu</button>
		</footer>

		<script>
			menuPathList = [];
			mainIdsList = []
			CREATE_ELS_NAMES_LIST = ["div", "span", "p", "input", "button"];
			clickedElName = "";
			activeListenerName = "";
			menuModalListeners = {
				create: (event) => {
					const divEL = event.target;

					if (!CREATE_ELS_NAMES_LIST.includes(divEL.innerHTML)) {
					    return;
					}

					clickedElName = divEL.innerHTML;
					addMenuModalHeader(clickedElName);
					
					const idInput = createEl({
					    tag: "input",
					    props: {
					        id: "elIdInput",
					        onblur: () => {
					            newId = elIdInput.value
					            if (newId && !mainIdsList.includes(newId)) {
					                maxId +=1;
					                createEl({
					                    tag: clickedElName,
					                    appendTo: "#main",
					                    props:{
					                        innerHTML: clickedElName,
					                        id: newId,
					                    },
					                    style: {
					                        "z-index": maxId,
					                        position: "absolute",
					                        top: 0,
					                        left: 0
					                    }
					                });
					                mainButtons.push(newId)
					                elIdInput.remove();
					                closeMenuModal();
					            }
					        },
					    }
					});
					menuModalMain.replaceChildren(idInput)
				},
			};

			buttonsAction = {
				create: () => {
					const createFragment = getFragment();

					CREATE_ELS_NAMES_LIST.forEach((tag) => {
						createFragment.append(createEl({ props:{innerHTML: tag }}));
					});

					menuModalMain.replaceChildren(createFragment);

					activeListenerName = "create";
					menuModalMain.addEventListener("click", menuModalListeners[activeListenerName]);
				},
				edit: () => {},
				delete: () => {},
			};
			maxDiff = 1;
			maxId = 1;
	

			function getPx(value) {
				return `${parseFloat(value)}px`;
			}

			function closeMenuModal() {
				menuModal.classList.remove("show");
				menuModalMain.removeEventListener("click", menuModalListeners[activeListenerName]);
				activeListenerName = "";
				menuPathList = [];
				menuModalHeader.replaceChildren();
				menuModalMain.replaceChildren();
			}

			function getFragment() {
				return document.createDocumentFragment();
			}

			function addMenuModalHeader(path) {
				const el = createEl({props:{ innerHTML: path }});

				if (!menuPathList.length) {
					button = createEl({props:{ innerHTML: "back", onclick: removeLastMenuModalHeader}, tag: "button" });
					menuModalHeader.append(button);
				}

				menuPathList.push(path);

				menuModalHeader.append(el);
			}

			function removeLastMenuModalHeader() {
				menuPathList.pop();

				menuModalHeader.removeChild(menuModalHeader.lastElementChild);
				menuModalMain.replaceChildren();

				if (!menuPathList.length) {
					closeMenuModal();
				}
			}

			function getMenuSection({ section = {}, pathIndex = 1 }) {
				if (!section.routes) return section;

				const path = menuPathList[pathIndex];
				const isLastMenuPath = pathIndex === menuPathList.length - 1;

				if (isLastMenuPath) return section;

				const currentSection = section.sections.find((childrenSection) => compare(childrenSection.name, path));

				if (currentSection) {
					return getMenuSection({ section: currentSection, index: pathIndex + 1 });
				}
			}

			function showMainModalButtons() {
				const mainButtons = getFragment();

				["create", "edit", "delete"].forEach((buttonName) => {
					mainButtons.append(
						createEl({
						    props:{
							innerHTML: buttonName,
							onclick: () => {
								addMenuModalHeader(buttonName);
								buttonsAction[buttonName]();
							}},
						})
					);
				});

				menuModalMain.append(mainButtons);
			}

			function toggleMenuModal() {
				menuModal.classList.add("show");
				menuModal.style.zIndex = maxId + 1;
				addMenuModalHeader("menu");
				showMainModalButtons();
			}

		

			function getCellInfo(element) {
				info = {
					top: parseFloat(element.style.top),
					left: parseFloat(element.style.left),
					width: parseFloat(element.style.width),
					height: parseFloat(element.style.height),
				};

				return {
					...info,
					bottom: info.top + info.height,
					right: info.left + info.width,
					id: +element.id,
				};
			}

			function createEl({
				tag = "div",
				datasets,
				style = {},
				appendTo = "",
				props,
			}) {
				const el = document.createElement(tag);
				
				if (datasets) datasets.forEach(({ value, name }) => (el.dataset[name] = value));
				if (style) {
					Object.keys(style).forEach((styleKey) => {
						el.style[styleKey] = style[styleKey];
					});
				}
				if (appendTo) document.querySelector(appendTo).append(el);
				if (props) {
					Object.keys(props).forEach((propName) => {
						el[propName] = props[propName];
					});
				}
				return el;
			}

			function rangeArray({ from = 0, to = 0, before = "", handler }) {
				const newArray = [];
				for (let index = from; index <= to; index++) {
					let value = `${before}${index}`;
					handler?.(value, index);
					newArray.push(value);
				}
				return newArray;
			}

			function compare(id1, id2) {
				return String(id1) === String(id2);
			}

			function log() {
				for (var i = 0; i < arguments.length; i++) {
					console.log(arguments[i]);
				}
			}
		</script>
	</body>
</html>
